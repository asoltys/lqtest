import { ProjectivePoint, etc, utils, CURVE } from "@noble/secp256k1";
import { sha256 } from "@noble/hashes/sha256";

// Modular exponentiation function
const modPow = (base, exp, mod) => {
  let result = 1n;
  base = etc.mod(base, mod);
  while (exp > 0) {
    if (exp % 2n === 1n) {
      result = etc.mod(result * base, mod);
    }
    exp = exp >> 1n;
    base = etc.mod(base * base, mod);
  }
  return result;
};

// Function to compute Jacobi symbol
const jacobiSymbol = (a, n) => {
  if (a === 0n) return 0;
  if (a === 1n) return 1;

  let s;
  if (a % 2n === 0n) {
    s = jacobiSymbol(a / 2n, n);
    if (n % 8n === 3n || n % 8n === 5n) s = -s;
  } else {
    s = jacobiSymbol(n % a, a);
    if (a % 4n === 3n && n % 4n === 3n) s = -s;
  }
  return s;
};

// Function to compute square root in a finite field
const sqrt = (n) => {
  return modPow(n, (CURVE.p + 1n) / 4n, CURVE.p);
};

// Function to normalize and convert field element to bytes
function normalizeAndConvertToBytes(fe) {
  return etc.numberToBytesBE(fe).slice(0, 32);
}

// Function to check if a field element is a quadratic residue
function isSquare(fe) {
  const normalized = etc.mod(fe, CURVE.p);

  if (normalized === 0n) return true;

  const jacobi = jacobiSymbol(normalized, CURVE.p);
  if (jacobi === -1) {
    return false;
  } else if (jacobi === 1) {
    return true;
  } else {
    const sqrtResult = sqrt(normalized);
    return sqrtResult ** 2n % CURVE.p === normalized;
  }
}

// JavaScript implementation of secp256k1_pedersen_commitment_save
function pedersenCommitmentSave(commit, ge) {
  // Normalize x-coordinate and convert to bytes
  const xBytes = normalizeAndConvertToBytes(ge.x);

  // Check if y-coordinate is a square
  const yIsSquare = isSquare(ge.y);

  // Set the prefix byte
  const prefixByte = 9 ^ (yIsSquare ? 1 : 0);

  // Prepare the commitment data
  commit.data = new Uint8Array(33);
  commit.data[0] = prefixByte;
  commit.data.set(xBytes, 1);
}

const print = (label, p) =>
  console.log(label, {
    hex: p.toHex(true),
    x: p.x.toString(16),
    y: p.y.toString(16),
  });

function testPedersen() {
  const blindHex =
    "8b5d87d94b9f54dc5dd9f31df5dffedc974fc4d5bf0d2ee1297e5aba504ccc26";
  const blindBytes = etc.hexToBytes(blindHex);
  const blindingFactor = etc.bytesToNumberBE(blindBytes);
  const B = ProjectivePoint.BASE.multiply(blindingFactor);
  const expectedHex =
    "08a9de5e391458abf4eb6ff0cc346fa0a8b5b0806b2ee9261dde54d436423c1982";

  const genHex =
    "02a4fd25e0e2108e55aec683810a8652f9b067242419a1f7cc0f01f92b4b078252";
  const value = 10000n;

  const G2 = ProjectivePoint.fromHex(genHex);
  const V = G2.multiply(value);

  // print("B", B);
  // print("V", V);
  // print("B + V", V.add(B));

  // Save the commitment
  const commitment = {};
  pedersenCommitmentSave(commitment, V.add(B));

  console.log(
    "Commitment matches expected:",
    etc.bytesToHex(commitment.data) === expectedHex,
  );
}

function borromeanHash(hash, m, e, ridx, eidx) {
  const ring = new Uint8Array(4);
  const epos = new Uint8Array(4);

  const writeBe32 = (buffer, value) => {
    buffer[0] = (value >> 24) & 0xff;
    buffer[1] = (value >> 16) & 0xff;
    buffer[2] = (value >> 8) & 0xff;
    buffer[3] = value & 0xff;
  };

  writeBe32(ring, ridx);
  writeBe32(epos, eidx);

  const sha256Context = sha256.create();
  sha256Context.update(e);
  sha256Context.update(m);
  sha256Context.update(ring);
  sha256Context.update(epos);

  const result = sha256Context.digest();
  hash.set(result);
}

function testBorromeanHash() {
  const hash = new Uint8Array(32);
  const message = new Uint8Array([
    /* message data */
  ]);
  const e = new Uint8Array([
    /* e data */
  ]);
  const ridx = 1; // example ring index
  const eidx = 2; // example element index

  borromeanHash(hash, message, e, ridx, eidx);
  console.log(etc.bytesToHex(hash));
}

function clz64(x) {
  if (x === 0n) return 64;
  let n = 0;
  while ((x & 0x8000000000000000n) === 0n) {
    x <<= 1n;
    n++;
  }
  return n;
}

function rangeProveParams(
  v,
  rings,
  rsizes,
  npub,
  secidx,
  minValue,
  mantissa,
  scale,
  exp,
  minBits,
  value,
) {
  let i;
  rings.value = 1;
  rsizes[0] = 1;
  secidx[0] = 0;
  scale.value = 1n;
  mantissa.value = 0;
  npub.value = 0;

  if (minValue.value === 0xffffffffffffffffn) {
    exp.value = -1;
  }

  if (exp.value >= 0) {
    let maxBits;
    let v2;
    if (
      (minValue.value && value > 0x7fffffffffffffffn) ||
      (value && minValue.value >= 0x7fffffffffffffffn)
    ) {
      return 0;
    }
    maxBits = minValue.value ? clz64(minValue.value) : 64;
    if (minBits.value > maxBits) {
      minBits.value = maxBits;
    }
    if (minBits.value > 61 || value > 0x7fffffffffffffffn) {
      exp.value = 0;
    }
    v.value = value - minValue.value;
    v2 = minBits.value ? 0xffffffffffffffffn >> BigInt(64 - minBits.value) : 0n;
    for (i = 0; i < exp.value && v2 <= 0xffffffffffffffffn / 10n; i++) {
      v.value /= 10n;
      v2 *= 10n;
    }
    exp.value = i;
    v2 = v.value;
    for (i = 0; i < exp.value; i++) {
      v2 *= 10n;
      scale.value *= 10n;
    }
    minValue.value = value - v2;
    mantissa.value = v.value ? 64 - clz64(v.value) : 1;
    if (minBits.value > mantissa.value) {
      mantissa.value = minBits.value;
    }
    rings.value = (mantissa.value + 1) >> 1;
    for (i = 0; i < rings.value; i++) {
      rsizes[i] = i < rings.value - 1 || !(mantissa.value & 1) ? 4 : 2;
      npub.value += rsizes[i];
      secidx[i] = Number((v.value >> BigInt(i * 2)) & 3n);
    }
    if (mantissa.value <= 0) throw new Error("Invalid mantissa value");
    if (
      (v.value & ~(0xffffffffffffffffn >> BigInt(64 - mantissa.value))) !==
      0n
    )
      throw new Error("Did not get all the bits");
  } else {
    exp.value = 0;
    minValue.value = value;
    v.value = 0n;
    npub.value = 2;
  }

  if (v.value * scale.value + minValue.value !== value)
    throw new Error("Invalid value");
  if (rings.value <= 0 || rings.value > 32)
    throw new Error("Invalid number of rings");
  if (npub.value > 128) throw new Error("Invalid number of public keys");

  return 1;
}

function testProveParams() {
  const v = { value: 0n };
  const rings = { value: 0 };
  const rsizes = new Array(32).fill(0);
  const npub = { value: 0 };
  const secidx = new Array(32).fill(0);
  const minValue = { value: 0n };
  const mantissa = { value: 0 };
  const scale = { value: 0n };
  const exp = { value: 0 };
  const minBits = { value: 0 };
  const value = 1000n;

  const result = rangeProveParams(
    v,
    rings,
    rsizes,
    npub,
    secidx,
    minValue,
    mantissa,
    scale,
    exp,
    minBits,
    value,
  );
  console.log(result);
  console.log({
    v,
    rings,
    rsizes,
    npub,
    secidx,
    minValue,
    mantissa,
    scale,
    exp,
    minBits,
  });
}

function testRange() {
  const value = 123455000n;
  const minval = 1;
  const exp = 0;
  const bits = 36;
  const valueCommitment =
    "0953c4bf412d07fad5e05fe0f5ea2107a546f9cfef38ef2b962ffd84a89de03d7f";
  const assetCommitment =
    "0a8d276fa2ab45fed0f622f818be77f456baa2f3b90456e30d2c561446b25b5458";
  const valueBlinder =
    "de22de5f5fe49cc6ac2bb8952567151c7c36b42e2e2f2aa587d4ed2060b2ba4d";
  const nonce =
    "f295f2c7a42274f8f90a9d7f8649d78b67e693703246bf6086653c8646a363f5";
  const script = "a914d7da691a2b7256aa3bce759ef2b8ff5213fa327987";
  const msg =
    "25b251070e29ca19043cf33ccd7324e2ddab03ecc4ae0b5e77c4fc0e5cf6c95ac4681a2583b714a31c5a0b997a6c107a96be4aef4847d9cde3035e8ef23642bf";
}

function borromeanSign(e0, s, pubs, k, sec, rsizes, secidx, nrings, m) {
  let rgej;
  let tmp = new Uint8Array(33);
  let count = 0;

  if (!e0 || !s || !pubs || !k || !sec || !rsizes || !secidx || !nrings || !m) {
    throw new Error("Invalid input");
  }

  const sha256_e0 = sha256.create();
  for (let i = 0; i < nrings; i++) {
    if (Number.MAX_SAFE_INTEGER - count < rsizes[i]) {
      throw new Error("Integer overflow");
    }

    rgej = ProjectivePoint.BASE.multiply(k[i]);
    if (rgej.equals(ProjectivePoint.ZERO)) {
      return 0;
    }

    tmp = rgej.toRawBytes(true);

    for (let j = secidx[i] + 1; j < rsizes[i]; j++) {
      borromeanHash(tmp, m, tmp, i, j);
      const ens = etc.bytesToNumberBE(tmp);

      if (ens === 0n || ens >= CURVE.n) {
        return 0;
      }

      rgej = pubs[count + j]
        .multiply(ens)
        .add(ProjectivePoint.BASE.multiply(s[count + j]));
      if (rgej.equals(ProjectivePoint.ZERO)) {
        return 0;
      }

      tmp = rgej.toRawBytes(true);
    }

    sha256_e0.update(tmp);
    count += rsizes[i];
  }

  sha256_e0.update(m);
  e0.set(sha256_e0.digest());

  count = 0;
  for (let i = 0; i < nrings; i++) {
    if (Number.MAX_SAFE_INTEGER - count < rsizes[i]) {
      throw new Error("Integer overflow");
    }

    borromeanHash(tmp, m, e0, i, 0);
    let ens = etc.bytesToNumberBE(tmp);

    if (ens === 0n || ens >= CURVE.n) {
      return 0;
    }

    for (let j = 0; j < secidx[i]; j++) {
      rgej = pubs[count + j]
        .multiply(ens)
        .add(ProjectivePoint.BASE.multiply(s[count + j]));
      if (rgej.equals(ProjectivePoint.ZERO)) {
        return 0;
      }

      tmp = rgej.toRawBytes(true);
      borromeanHash(tmp, m, tmp, i, j + 1);
      ens = etc.bytesToNumberBE(tmp);

      if (ens === 0n || ens >= CURVE.n) {
        return 0;
      }
    }

    const secScalar = etc.bytesToNumberBE(sec[i]);
    const kScalar = etc.bytesToNumberBE(k[i]);
    const newS = mod(ens * secScalar + kScalar, CURVE.n);
    s[count + secidx[i]] = etc.numberToBytesBE(newS, 32);

    if (newS === 0n) {
      return 0;
    }

    count += rsizes[i];
  }

  return 1;
}

function borromeanHash(hash, m, e, ridx, eidx) {
  const ring = new Uint8Array(4);
  const epos = new Uint8Array(4);

  const writeBe32 = (buffer, value) => {
    buffer[0] = (value >> 24) & 0xff;
    buffer[1] = (value >> 16) & 0xff;
    buffer[2] = (value >> 8) & 0xff;
    buffer[3] = value & 0xff;
  };

  writeBe32(ring, ridx);
  writeBe32(epos, eidx);

  const sha256Context = sha256.create();
  sha256Context.update(e);
  sha256Context.update(m);
  sha256Context.update(ring);
  sha256Context.update(epos);

  const result = sha256Context.digest();
  hash.set(result);
}

function testBorromeanSign() {
  const e0 = new Uint8Array([
    0xf7, 0x0c, 0x00, 0x80, 0x98, 0xc2, 0xbc, 0x1d, 0xad, 0x00, 0x00, 0x93,
    0x4c, 0x56, 0x04, 0xd5, 0x3d, 0x13, 0x00, 0xa3, 0x36, 0xa0, 0x0f, 0x08,
    0x49, 0x00, 0x00, 0x00, 0x97, 0x4e, 0xe3, 0x15,
  ]);

  const s = [
    new Uint8Array([
      0x3c, 0x7e, 0xb2, 0xd4, 0xf1, 0x20, 0x23, 0x6c, 0xb0, 0xdf, 0xe3, 0x94,
      0x5b, 0x69, 0x6b, 0xe7, 0x7c, 0x47, 0xcf, 0x1a, 0x29, 0xe2, 0x35, 0xc3,
      0x58, 0x04, 0xf2, 0x3f, 0xf1, 0xac, 0x85, 0x25,
    ]),
    new Uint8Array([
      0xa6, 0x0a, 0x04, 0x0d, 0x5f, 0x07, 0x80, 0xed, 0xa7, 0xb7, 0x1f, 0xe2,
      0xd9, 0x56, 0xcc, 0xaa, 0x5d, 0xd7, 0xf9, 0xfe, 0x4d, 0xb3, 0x10, 0xe4,
      0x6f, 0xa1, 0x9f, 0x0b, 0x49, 0x3f, 0x7a, 0x90,
    ]),
    new Uint8Array([
      0xa6, 0x6a, 0xfd, 0x71, 0xfc, 0x5e, 0x84, 0xb9, 0xf3, 0x9c, 0x81, 0x4e,
      0xcb, 0xc0, 0x60, 0x5b, 0xb3, 0xb0, 0xef, 0xb7, 0x84, 0x24, 0x84, 0x6d,
      0x0f, 0x1b, 0x83, 0x1b, 0xbc, 0xcd, 0x8e, 0x0f,
    ]),
    new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    new Uint8Array([
      0xcd, 0x6e, 0x07, 0x1a, 0x6d, 0xe6, 0x24, 0xf1, 0x6c, 0x92, 0x32, 0x81,
      0x77, 0xee, 0x48, 0xe8, 0xe3, 0x54, 0x45, 0xb5, 0xb3, 0x30, 0xae, 0xd0,
      0x00, 0xda, 0xa2, 0xf4, 0xeb, 0xe5, 0xc1, 0x7e,
    ]),
    new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    new Uint8Array([
      0x23, 0x84, 0xa6, 0x00, 0xc3, 0x9a, 0x57, 0xb7, 0x10, 0x44, 0xfe, 0xe0,
      0xd9, 0x76, 0x02, 0x2e, 0x37, 0x6f, 0xcd, 0xc2, 0xd8, 0x35, 0x44, 0x33,
      0x0e, 0x5b, 0xc9, 0x43, 0x84, 0xd0, 0x89, 0xde,
    ]),
    new Uint8Array([
      0x45, 0xc1, 0x87, 0x2f, 0x40, 0xa3, 0x96, 0x1e, 0x8f, 0xd6, 0xf4, 0xcb,
      0xf3, 0xac, 0x13, 0x1a, 0x44, 0x68, 0x8a, 0x72, 0x14, 0xc1, 0x53, 0x25,
      0xba, 0x89, 0xac, 0x7a, 0x55, 0xaa, 0x87, 0x90,
    ]),
    new Uint8Array([
      0x4f, 0x6f, 0x33, 0x82, 0x8e, 0x1f, 0x43, 0x2b, 0xb8, 0xf0, 0xf0, 0x40,
      0xd8, 0x40, 0x3c, 0x87, 0x30, 0x0a, 0x7a, 0xc0, 0xa1, 0x46, 0xdd, 0x87,
      0xaf, 0x4f, 0x1a, 0xff, 0x96, 0xf4, 0x28, 0xf4,
    ]),
    new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    new Uint8Array([
      0x83, 0x9b, 0xb1, 0xef, 0xde, 0xf7, 0x82, 0x34, 0xc6, 0xd0, 0x7c, 0x75,
      0x89, 0x1e, 0x9a, 0x0a, 0x9d, 0xfd, 0x9f, 0x2d, 0xe5, 0xcd, 0xd4, 0xa6,
      0xb8, 0x98, 0xda, 0xd8, 0x02, 0x54, 0xaf, 0xb6,
    ]),
    new Uint8Array([
      0xae, 0x9d, 0x76, 0x3b, 0xc3, 0x86, 0x0e, 0x0b, 0x19, 0xae, 0x7d, 0xe5,
      0x5a, 0x27, 0xd9, 0x35, 0x57, 0x6e, 0x8b, 0x75, 0x75, 0x84, 0x6d, 0x2b,
      0xef, 0xd2, 0x51, 0xd8, 0xd4, 0xb0, 0xf6, 0x2b,
    ]),
    new Uint8Array([
      0x2f, 0x10, 0x37, 0x49, 0x93, 0x3d, 0xb2, 0x14, 0x86, 0x13, 0x0a, 0x56,
      0xbe, 0x1b, 0xca, 0xee, 0x78, 0x13, 0x7e, 0xf8, 0x30, 0x6d, 0xc5, 0xbe,
      0xc2, 0xb3, 0xaf, 0xe9, 0xaf, 0xcc, 0x43, 0x44,
    ]),
    new Uint8Array([
      0xd4, 0xac, 0xa0, 0xe4, 0xf1, 0x73, 0xd5, 0x03, 0x58, 0x38, 0x72, 0x14,
      0x1f, 0x4d, 0xa1, 0x9a, 0x45, 0xaa, 0x2b, 0x0f, 0x2f, 0xb1, 0xa1, 0x5d,
      0xc3, 0xd9, 0xe2, 0xf6, 0xa1, 0x89, 0x94, 0x8e,
    ]),
    new Uint8Array([
      0xee, 0x28, 0x5d, 0xa3, 0x79, 0x68, 0xcc, 0x35, 0xb3, 0x4c, 0x93, 0xdb,
      0x92, 0x42, 0x10, 0x03, 0x89, 0x3f, 0xf6, 0xac, 0xa7, 0xc9, 0x0c, 0x89,
      0xd4, 0x6b, 0x77, 0x16, 0x69, 0xcd, 0x43, 0xae,
    ]),
    new Uint8Array([
      0x3f, 0x4d, 0x4a, 0x2e, 0x04, 0x71, 0x83, 0xbc, 0x15, 0xae, 0x38, 0xca,
      0xc4, 0x85, 0xb7, 0xea, 0x05, 0x01, 0x50, 0x01, 0x35, 0x47, 0x50, 0x6b,
      0x3f, 0xff, 0xfb, 0x38, 0xca, 0x9f, 0x4f, 0x43,
    ]),
    new Uint8Array([
      0x62, 0x4a, 0xed, 0xf0, 0xee, 0x54, 0xfe, 0xb5, 0xe1, 0x40, 0x22, 0x51,
      0x16, 0xe8, 0x69, 0xfe, 0x1d, 0x3c, 0x5e, 0x45, 0xc0, 0x56, 0x4d, 0x13,
      0x0f, 0xa1, 0xa6, 0xb1, 0x31, 0x91, 0xed, 0x59,
    ]),
  ];

  const pubs = [
    new ProjectivePoint(
      new Uint8Array([
        0x3c, 0x7e, 0xb2, 0xd4, 0xf1, 0x20, 0x23, 0x6c, 0xb0, 0xdf, 0xe3, 0x94,
        0x5b, 0x69, 0x6b, 0xe7, 0x7c, 0x47, 0xcf, 0x1a, 0x29, 0xe2, 0x35, 0xc3,
        0x58, 0x04, 0xf2, 0x3f, 0xf1, 0xac, 0x85, 0x25, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xa6, 0x0a, 0x04, 0x0d, 0x5f, 0x07, 0x80, 0xed, 0xa7, 0xb7, 0x1f, 0xe2,
        0xd9, 0x56, 0xcc, 0xaa, 0x5d, 0xd7, 0xf9, 0xfe, 0x4d, 0xb3, 0x10, 0xe4,
        0x6f, 0xa1, 0x9f, 0x0b, 0x49, 0x3f, 0x7a, 0x90, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xa6, 0x6a, 0xfd, 0x71, 0xfc, 0x5e, 0x84, 0xb9, 0xf3, 0x9c, 0x81, 0x4e,
        0xcb, 0xc0, 0x60, 0x5b, 0xb3, 0xb0, 0xef, 0xb7, 0x84, 0x24, 0x84, 0x6d,
        0x0f, 0x1b, 0x83, 0x1b, 0xbc, 0xcd, 0x8e, 0x0f, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xcd, 0x6e, 0x07, 0x1a, 0x6d, 0xe6, 0x24, 0xf1, 0x6c, 0x92, 0x32, 0x81,
        0x77, 0xee, 0x48, 0xe8, 0xe3, 0x54, 0x45, 0xb5, 0xb3, 0x30, 0xae, 0xd0,
        0x00, 0xda, 0xa2, 0xf4, 0xeb, 0xe5, 0xc1, 0x7e, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x23, 0x84, 0xa6, 0x00, 0xc3, 0x9a, 0x57, 0xb7, 0x10, 0x44, 0xfe, 0xe0,
        0xd9, 0x76, 0x02, 0x2e, 0x37, 0x6f, 0xcd, 0xc2, 0xd8, 0x35, 0x44, 0x33,
        0x0e, 0x5b, 0xc9, 0x43, 0x84, 0xd0, 0x89, 0xde, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x45, 0xc1, 0x87, 0x2f, 0x40, 0xa3, 0x96, 0x1e, 0x8f, 0xd6, 0xf4, 0xcb,
        0xf3, 0xac, 0x13, 0x1a, 0x44, 0x68, 0x8a, 0x72, 0x14, 0xc1, 0x53, 0x25,
        0xba, 0x89, 0xac, 0x7a, 0x55, 0xaa, 0x87, 0x90, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x4f, 0x6f, 0x33, 0x82, 0x8e, 0x1f, 0x43, 0x2b, 0xb8, 0xf0, 0xf0, 0x40,
        0xd8, 0x40, 0x3c, 0x87, 0x30, 0x0a, 0x7a, 0xc0, 0xa1, 0x46, 0xdd, 0x87,
        0xaf, 0x4f, 0x1a, 0xff, 0x96, 0xf4, 0x28, 0xf4, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x83, 0x9b, 0xb1, 0xef, 0xde, 0xf7, 0x82, 0x34, 0xc6, 0xd0, 0x7c, 0x75,
        0x89, 0x1e, 0x9a, 0x0a, 0x9d, 0xfd, 0x9f, 0x2d, 0xe5, 0xcd, 0xd4, 0xa6,
        0xb8, 0x98, 0xda, 0xd8, 0x02, 0x54, 0xaf, 0xb6, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xae, 0x9d, 0x76, 0x3b, 0xc3, 0x86, 0x0e, 0x0b, 0x19, 0xae, 0x7d, 0xe5,
        0x5a, 0x27, 0xd9, 0x35, 0x57, 0x6e, 0x8b, 0x75, 0x75, 0x84, 0x6d, 0x2b,
        0xef, 0xd2, 0x51, 0xd8, 0xd4, 0xb0, 0xf6, 0x2b, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x2f, 0x10, 0x37, 0x49, 0x93, 0x3d, 0xb2, 0x14, 0x86, 0x13, 0x0a, 0x56,
        0xbe, 0x1b, 0xca, 0xee, 0x78, 0x13, 0x7e, 0xf8, 0x30, 0x6d, 0xc5, 0xbe,
        0xc2, 0xb3, 0xaf, 0xe9, 0xaf, 0xcc, 0x43, 0x44, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xd4, 0xac, 0xa0, 0xe4, 0xf1, 0x73, 0xd5, 0x03, 0x58, 0x38, 0x72, 0x14,
        0x1f, 0x4d, 0xa1, 0x9a, 0x45, 0xaa, 0x2b, 0x0f, 0x2f, 0xb1, 0xa1, 0x5d,
        0xc3, 0xd9, 0xe2, 0xf6, 0xa1, 0x89, 0x94, 0x8e, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0xee, 0x28, 0x5d, 0xa3, 0x79, 0x68, 0xcc, 0x35, 0xb3, 0x4c, 0x93, 0xdb,
        0x92, 0x42, 0x10, 0x03, 0x89, 0x3f, 0xf6, 0xac, 0xa7, 0xc9, 0x0c, 0x89,
        0xd4, 0x6b, 0x77, 0x16, 0x69, 0xcd, 0x43, 0xae, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x3f, 0x4d, 0x4a, 0x2e, 0x04, 0x71, 0x83, 0xbc, 0x15, 0xae, 0x38, 0xca,
        0xc4, 0x85, 0xb7, 0xea, 0x05, 0x01, 0x50, 0x01, 0x35, 0x47, 0x50, 0x6b,
        0x3f, 0xff, 0xfb, 0x38, 0xca, 0x9f, 0x4f, 0x43, 0x38,
      ]),
    ),
    new ProjectivePoint(
      new Uint8Array([
        0x62, 0x4a, 0xed, 0xf0, 0xee, 0x54, 0xfe, 0xb5, 0xe1, 0x40, 0x22, 0x51,
        0x16, 0xe8, 0x69, 0xfe, 0x1d, 0x3c, 0x5e, 0x45, 0xc0, 0x56, 0x4d, 0x13,
        0x0f, 0xa1, 0xa6, 0xb1, 0x31, 0x91, 0xed, 0x59, 0x38,
      ]),
    ),
  ];

  const k = [
    new Uint8Array([
      0x13, 0x08, 0xfb, 0x12, 0xe8, 0xf1, 0xf7, 0xe9, 0x9d, 0x89, 0x9e, 0x68,
      0x67, 0xed, 0x39, 0xdf, 0x23, 0xa2, 0x70, 0x3a, 0xe5, 0x3c, 0x36, 0x2d,
      0xe2, 0x03, 0xa2, 0x34, 0x1a, 0x1d, 0x5d, 0xc4,
    ]),
    new Uint8Array([
      0xb7, 0x33, 0x9e, 0xea, 0xd9, 0x99, 0x0d, 0xbc, 0x46, 0x6f, 0xb6, 0x51,
      0x39, 0xac, 0xff, 0xc2, 0x27, 0x29, 0xc2, 0x7d, 0x24, 0x7b, 0x6d, 0xe5,
      0x63, 0x84, 0x06, 0x83, 0x79, 0x49, 0x3b, 0x0e,
    ]),
    new Uint8Array([
      0xa2, 0x1c, 0x74, 0xde, 0x46, 0x2d, 0x4a, 0xdf, 0xd6, 0xc7, 0x23, 0xcf,
      0x24, 0x1f, 0x04, 0xbe, 0x1f, 0x3a, 0xfe, 0x12, 0x27, 0xca, 0xb7, 0x67,
      0x11, 0xe9, 0xe2, 0x5f, 0x3e, 0x43, 0x45, 0xf3,
    ]),
    new Uint8Array([
      0x62, 0xf7, 0xdb, 0xb4, 0x9a, 0x68, 0xb6, 0xba, 0x4a, 0x71, 0x49, 0x7d,
      0x25, 0x02, 0x12, 0x29, 0x29, 0x06, 0x53, 0x0c, 0x51, 0xdf, 0x3e, 0xf1,
      0xe3, 0x81, 0x55, 0xfb, 0x7b, 0x0a, 0x1d, 0xc6,
    ]),
    new Uint8Array([
      0xbd, 0x60, 0xbf, 0x9f, 0x7f, 0xa1, 0xee, 0x6e, 0xc8, 0x9a, 0xcd, 0xbf,
      0x79, 0x5e, 0x57, 0xc5, 0x5c, 0x62, 0x91, 0xaa, 0x41, 0x06, 0x53, 0xee,
      0x9e, 0xee, 0x15, 0xeb, 0x73, 0xc3, 0xf4, 0x83,
    ]),
    new Uint8Array([
      0xdd, 0xf9, 0xa1, 0x28, 0xc5, 0xe2, 0xe5, 0x7f, 0x12, 0x22, 0x67, 0xac,
      0x2f, 0x02, 0x26, 0xee, 0x99, 0xc4, 0xe8, 0x8e, 0x69, 0x60, 0xe0, 0xfd,
      0xf3, 0x9e, 0x5d, 0x3b, 0x8b, 0x71, 0x15, 0x41,
    ]),
    new Uint8Array([
      0xa8, 0xab, 0xe9, 0x1d, 0x98, 0xee, 0x07, 0x79, 0xe1, 0x6c, 0xfe, 0xc1,
      0x59, 0x14, 0x8c, 0xa6, 0xbe, 0x7f, 0xf8, 0xc9, 0x71, 0xf1, 0xd2, 0x0d,
      0x38, 0x62, 0x29, 0x9f, 0x12, 0x4f, 0x04, 0x08,
    ]),
    new Uint8Array([
      0xee, 0x5d, 0x08, 0xbe, 0x93, 0xc4, 0xb1, 0x14, 0x45, 0xe6, 0xe4, 0xa2,
      0x1a, 0x89, 0x28, 0xbd, 0x92, 0x91, 0x4a, 0x98, 0xb8, 0x02, 0x42, 0xac,
      0x55, 0xe0, 0xe0, 0x83, 0xfd, 0xc9, 0x4e, 0xf8,
    ]),
    new Uint8Array([
      0x70, 0x22, 0xd0, 0x5f, 0x64, 0x0b, 0xf9, 0x9a, 0xac, 0x35, 0xec, 0xa3,
      0xd8, 0x22, 0x8b, 0xb2, 0x5e, 0x8e, 0x23, 0x7a, 0x91, 0x74, 0x9f, 0x83,
      0xc3, 0xc6, 0xb4, 0xd3, 0xa6, 0xd4, 0xdd, 0xad,
    ]),
    new Uint8Array([
      0x6c, 0xbe, 0xfb, 0x50, 0x1c, 0x14, 0xc6, 0xf1, 0xb0, 0x7a, 0xd1, 0xe3,
      0x2e, 0x8b, 0x38, 0x77, 0x74, 0xc8, 0x20, 0x2c, 0xea, 0x72, 0x01, 0x73,
      0x16, 0x81, 0x85, 0x27, 0xf8, 0xf1, 0x20, 0xf4,
    ]),
    new Uint8Array([
      0xa2, 0xcf, 0x1e, 0xb5, 0x6c, 0xe7, 0xfe, 0xcf, 0x7e, 0x23, 0x72, 0xd1,
      0xd3, 0xc0, 0x97, 0xa7, 0xc6, 0x52, 0x5c, 0x99, 0x8b, 0x14, 0xe5, 0x3a,
      0x2f, 0x59, 0x7d, 0x84, 0x8b, 0x2f, 0x95, 0xa0,
    ]),
    new Uint8Array([
      0x03, 0xe0, 0x72, 0x3e, 0x12, 0xd7, 0xea, 0x3c, 0xae, 0x33, 0xc7, 0x7a,
      0x27, 0x7f, 0x61, 0xa7, 0x8b, 0x0c, 0xbd, 0x4a, 0x15, 0x6e, 0x31, 0x2c,
      0x12, 0x4c, 0x34, 0x42, 0x25, 0x38, 0xf3, 0x26,
    ]),
    new Uint8Array([
      0xc8, 0x0d, 0x7a, 0xba, 0xe2, 0x40, 0xc9, 0x2f, 0xaa, 0x69, 0x85, 0xed,
      0x51, 0xd9, 0x03, 0x8a, 0xd7, 0xae, 0x90, 0x5e, 0xe8, 0x52, 0x17, 0x70,
      0xcf, 0xf2, 0x52, 0xde, 0x21, 0xfe, 0x83, 0xcc,
    ]),
    new Uint8Array([
      0xb2, 0x92, 0xab, 0xfb, 0x9e, 0x08, 0xbf, 0x06, 0xc4, 0xcb, 0x38, 0xba,
      0x17, 0x84, 0x21, 0xac, 0x93, 0xf3, 0xd0, 0x50, 0xcc, 0x31, 0x33, 0x25,
      0x3b, 0x05, 0xc6, 0x4c, 0x7a, 0x98, 0x7f, 0xb8,
    ]),
  ].map(etc.bytesToNumberBE);

  const sec = [
    new Uint8Array([
      0xfc, 0xd1, 0xe9, 0xfb, 0xa1, 0x66, 0xf3, 0x6d, 0x78, 0xf9, 0x34, 0xa4,
      0xd2, 0x71, 0x9c, 0x64, 0x1e, 0x7d, 0x5d, 0xcd, 0x6c, 0xba, 0x35, 0xcc,
      0xb9, 0x81, 0xfb, 0xe3, 0x64, 0xa1, 0x2c, 0xa2,
    ]),
    new Uint8Array([
      0xbc, 0x5e, 0xdd, 0x51, 0x82, 0x07, 0xb7, 0x30, 0xd2, 0x19, 0x3a, 0xa9,
      0xfb, 0x64, 0x1b, 0x07, 0x15, 0x54, 0x5a, 0x17, 0x84, 0x7b, 0x87, 0xc7,
      0xde, 0xa5, 0xc5, 0x7c, 0xbf, 0xc7, 0xaf, 0xef,
    ]),
    new Uint8Array([
      0xdb, 0xac, 0x69, 0xbc, 0x80, 0xa4, 0x84, 0xe8, 0x5e, 0x50, 0x77, 0x95,
      0x4d, 0x16, 0xce, 0x42, 0xea, 0xa0, 0xa7, 0x17, 0x53, 0x1f, 0xba, 0xe9,
      0xe5, 0xb1, 0x22, 0xb7, 0x4e, 0x00, 0x6e, 0x55,
    ]),
    new Uint8Array([
      0x17, 0x0a, 0x28, 0x6b, 0x5e, 0xb5, 0x9f, 0x9e, 0x80, 0x37, 0xe0, 0x09,
      0x83, 0x6b, 0xa8, 0x08, 0x66, 0xee, 0xa3, 0x4b, 0xb2, 0x1c, 0x0f, 0xd2,
      0xd6, 0x43, 0x4b, 0xee, 0xb6, 0x06, 0x7b, 0x5f,
    ]),
    new Uint8Array([
      0x62, 0x81, 0xc2, 0x19, 0xcf, 0x0f, 0xba, 0x57, 0x37, 0xb7, 0x2b, 0xb2,
      0x1a, 0x9e, 0xc4, 0x7a, 0xd7, 0xa5, 0xe2, 0x57, 0xf3, 0x08, 0x4f, 0xf6,
      0x5c, 0x14, 0xcc, 0x76, 0x47, 0x6a, 0xc6, 0x36,
    ]),
    new Uint8Array([
      0x1c, 0xdc, 0x2e, 0xb2, 0xe0, 0xfd, 0x95, 0xce, 0xe7, 0xc7, 0x8a, 0x48,
      0x15, 0x76, 0x89, 0xd5, 0xc6, 0xc3, 0xa6, 0x2e, 0x12, 0xd9, 0x54, 0x19,
      0x87, 0x82, 0xcd, 0xcd, 0x9d, 0x7b, 0x45, 0xa4,
    ]),
    new Uint8Array([
      0xfd, 0x69, 0x17, 0x81, 0xcc, 0x5c, 0x00, 0x08, 0x2e, 0x48, 0x46, 0x25,
      0xee, 0xc1, 0xc0, 0x2e, 0xbb, 0x91, 0x6c, 0xf5, 0x45, 0xd7, 0x57, 0x3d,
      0xe6, 0x11, 0x01, 0x21, 0x02, 0x12, 0xee, 0x0f,
    ]),
    new Uint8Array([
      0x33, 0xf1, 0x55, 0xf9, 0xa5, 0x0b, 0x9a, 0x54, 0x0e, 0xef, 0xef, 0xa5,
      0xa3, 0xb1, 0xab, 0x55, 0xb8, 0x6f, 0x2b, 0x69, 0x38, 0x15, 0xbe, 0xde,
      0x11, 0xf3, 0xe4, 0xd7, 0x00, 0xd8, 0x2e, 0x4f,
    ]),
    new Uint8Array([
      0x33, 0xc9, 0x6c, 0x89, 0xa5, 0xf8, 0x74, 0xee, 0xc5, 0x4b, 0x6e, 0x9c,
      0x7b, 0x66, 0xfe, 0x46, 0x36, 0x4b, 0x58, 0xdc, 0xe0, 0xb1, 0xbf, 0xa5,
      0xeb, 0x3f, 0x6a, 0xe7, 0x1d, 0x71, 0xac, 0x6a,
    ]),
    new Uint8Array([
      0x97, 0xbb, 0xee, 0x1e, 0x80, 0x47, 0x9c, 0x9b, 0x31, 0x98, 0xc6, 0x46,
      0x14, 0x28, 0xb2, 0xaa, 0x1e, 0x74, 0x82, 0x43, 0x06, 0xa6, 0x2e, 0x6d,
      0x01, 0x63, 0xc7, 0x32, 0xaf, 0x7e, 0xb1, 0x68,
    ]),
    new Uint8Array([
      0xa1, 0xdf, 0x09, 0xee, 0xc4, 0x49, 0x24, 0xad, 0x0b, 0x5d, 0x98, 0x53,
      0xb7, 0xe3, 0x25, 0xf9, 0xa8, 0xe9, 0xe7, 0x5c, 0x6e, 0x15, 0xe5, 0x67,
      0x06, 0xda, 0x24, 0x44, 0x56, 0x7d, 0x66, 0xe5,
    ]),
    new Uint8Array([
      0x88, 0xee, 0xa0, 0xde, 0x44, 0x85, 0xa1, 0x81, 0xed, 0x41, 0xa2, 0xfd,
      0x0e, 0x2b, 0xde, 0xcc, 0x40, 0x9d, 0xdc, 0xa9, 0x22, 0x1e, 0x22, 0x98,
      0x74, 0x4f, 0x2d, 0x2b, 0x83, 0x1e, 0x9c, 0x38,
    ]),
    new Uint8Array([
      0x33, 0xc9, 0x6c, 0x89, 0xa5, 0xf8, 0x74, 0xee, 0xc5, 0x4b, 0x6e, 0x9c,
      0x7b, 0x66, 0xfe, 0x46, 0x36, 0x4b, 0x58, 0xdc, 0xe0, 0xb1, 0xbf, 0xa5,
      0xeb, 0x3f, 0x6a, 0xe7, 0x1d, 0x71, 0xac, 0x6a,
    ]),
    new Uint8Array([
      0x74, 0xf6, 0x30, 0x71, 0x04, 0xec, 0xea, 0x89, 0x6c, 0x0f, 0xad, 0x18,
      0xbf, 0x1e, 0x92, 0x35, 0x22, 0x08, 0xf5, 0xe5, 0x82, 0x5d, 0x14, 0x22,
      0xb9, 0x4b, 0x80, 0x52, 0xb2, 0x27, 0xaa, 0x0e,
    ]),
    new Uint8Array([
      0x55, 0x31, 0xc6, 0x7d, 0x80, 0xc3, 0xa5, 0x48, 0x75, 0xd4, 0x94, 0x8f,
      0xf1, 0x10, 0x2d, 0x44, 0x43, 0x45, 0xbe, 0x35, 0x98, 0x6c, 0xf1, 0x06,
      0x96, 0xd9, 0x95, 0xf3, 0x4e, 0x81, 0xf6, 0x66,
    ]),
    new Uint8Array([
      0x88, 0xee, 0xa0, 0xde, 0x44, 0x85, 0xa1, 0x81, 0xed, 0x41, 0xa2, 0xfd,
      0x0e, 0x2b, 0xde, 0xcc, 0x40, 0x9d, 0xdc, 0xa9, 0x22, 0x1e, 0x22, 0x98,
      0x74, 0x4f, 0x2d, 0x2b, 0x83, 0x1e, 0x9c, 0x38,
    ]),
    new Uint8Array([
      0x33, 0xc9, 0x6c, 0x89, 0xa5, 0xf8, 0x74, 0xee, 0xc5, 0x4b, 0x6e, 0x9c,
      0x7b, 0x66, 0xfe, 0x46, 0x36, 0x4b, 0x58, 0xdc, 0xe0, 0xb1, 0xbf, 0xa5,
      0xeb, 0x3f, 0x6a, 0xe7, 0x1d, 0x71, 0xac, 0x6a,
    ]),
  ];

  const rsizes = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4];

  const secidx = [3, 1, 1, 0, 2, 1, 0, 3, 3, 2, 1, 1, 3, 1, 0, 0, 0, 0];

  const nrings = 18;

  const m = new Uint8Array([
    0x0f, 0x6f, 0x44, 0xb3, 0xc1, 0x2f, 0x82, 0x5f, 0x72, 0x82, 0x13, 0x7b,
    0x88, 0x70, 0x69, 0x15, 0xe0, 0x5f, 0xaf, 0xad, 0x5a, 0xbd, 0x89, 0x00,
    0xff, 0xd8, 0x99, 0xe0, 0xe3, 0x88, 0x7d, 0xc2,
  ]);

  const e0Final =
    "a5ebba7c91664a2f7be6863e9eccbb2b925d8b0451bc2333f860d21e18c1d071";

  const finalS = [
    "3c7eb2d4f120236cb0dfe3945b696be77c47cf1a29e235c35804f23ff1ac8525",
    "a60a040d5f0780eda7b71fe2d956ccaa5dd7f9fe4db310e46fa19f0b493f7a90",
    "a66afd71fc5e84b9f39c814ecbc0605bb3b0efb78424846d0f1b831bbccd8e0f",
    "d4fc0f4aeafe4893208cd84ebc75f5619f9af9e0f68adc0484b71b23018bbeef",
    "cd6e071a6de624f16c92328177ee48e8e35445b5b330aed000daa2f4ebe5c17e",
    "8532b9c5a0ab4a477c1cdc32e0125506d159816011cf581924ef9b138cdca823",
    "2384a600c39a57b71044fee0d976022e376fcdc2d83544330e5bc94384d089de",
    "45c1872f40a3961e8fd6f4cbf3ac131a44688a7214c15325ba89ac7a55aa8790",
    "4f6f33828e1f432bb8f0f040d8403c87300a7ac0a146dd87af4f1aff96f428f4",
    "dbb1dd35538b44b0de4076793b2f1c70cc5d3916d6bd70e770bd891f8461a27a",
    "839bb1efdef78234c6d07c75891e9a0a9dfd9f2de5cdd4a6b898dad80254afb6",
    "ae9d763bc3860e0b19ae7de55a27d935576e8b7575846d2befd251d8d4b0f62b",
    "3f78436439ffab4cb4edc663d58c053474f3631d98cddcae7c9342cbac6bc2e5",
    "2f103749933db21486130a56be1bcaee78137ef8306dc5bec2b3afe9afcc4344",
    "d4aca0e4f173d503583872141f4da19a45aa2b0f2fb1a15dc3d9e2f6a189948e",
    "ee285da37968cc35b34c93db92421003893ff6aca7c90c89d46b771669cd43ae",
    "3f4d4a2e047183bc15ae38cac485b7ea050150013547506b3fffb38ca9f4f433",
    "624aedf0ee54feb5e140225116e869fe1d3c5e45c0564d130fa1a6b13191ed59",
    "2a9bf0c49198db1a62d1a6da7ed7cd3027937c4f8817888678514b1c503f013c",
    "98bd230af3a180ebe57f559632cb65a0dc806fd34b6f2d57da6e385207cfb903",
    "68f5efbaa6fc7a118e6b8805628321bef76db29aafc4edf9c76a10f66bf18fd8",
    "b3cac4c9ef23574272d4b89f055d2cd1f5759d027b93301c7b3bbe7cd137c9dc",
    "a5fa59141dc32bddb9c6167a01a612413b3c2d830c3d0d4c1631994556180c5f",
    "ba28ee3780875cfb43525b1cc586901aa6b933be18d514975f84ca40ba080686",
    "6d48b62419ccb92f97a67538387529959de7df9b5760a11d669a666f7d069426",
    "3dbd798d1faaf31e6f6c3ec7e374132475d2fc05d29e5b7b43d8d8f342a71520",
    "8ce598893efae6991d1b49c94687e31a0b8749740b70e58e4d0ccb053ab0d8cd",
    "470f9ad08fe66ea91c3d1b56ccc6f2d98d054783d5bc7c57b9660cd316a61485",
    "e96be30379537859a58021734e4b4357c3a196a17e089299cd22023cfa3e7b25",
    "08ee70b904fea821df6edd03d8fdaccf4b4560388c00681c47b9462697897a46",
    "1f4247ab69207a9e1316781daf3eb32a22bdd60dc7b9f9e3bff087e137a65714",
    "abcfd47f493b9cdb1f844e7f117499150a8a3d5380c982d65e42a4366f683ef4",
    "dfd7f8de1289e30c3cd531afeabac4202541ca7dae26877fd2e184a9911e0cf2",
    "95be51d2febcedcfce480abcf7ce1bf7e4c0a311ab9542f4869e3e78b5638a07",
    "fe304f14d2aa7ca1577ca87bfc8e6de0ee8f6f2c10223bcc51eb13b2683373ad",
    "f10cd50098848c1e7640831db154c63c55655f610c03dbc83d7e761003d8ffb9",
    "e5012ffcff45b70917abcd429aa7d1c432ef7e0be417c989a59a3264edc2a731",
    "fe9ed0b2296cfaf2c27f5b225b018f190c6d37f177427875bf362c8197e5c984",
    "ad483142310e351e42697339305bc9885a9d9da9a16b96a9a72d279f2b1be829",
    "dfa81312edd35d125580e55b82fe6a99688bd7ac2082d33cac20b1f5ca5b52b1",
    "2ba1846ff4c942b04fae07a0b12d61449ed750cc366e865dc28a96a75761e824",
    "09fd055d24410228d1599ec5781c33eb6f0cea57a7982e13adeb81d2a0f6e052",
    "895e4b81c17656452caa74709191029ce41c962f3d8619d67445ab3debe5c75e",
    "6c128d618b9b98f1808a2b88a004996daa07d16e616ab1d6a1af563c3779a08a",
    "2f0dd2c9574ff7843907a20474d2ca34b1bddc999dad355a28178ed6c0f254ce",
    "bbd64e8ba30f11394d40a6bbe63aed53ed3d08a1a561801857e8648fe8621c34",
    "ce3230dc498ccf189e596e50fef40f975f8be9369da5abc372f367c84e0844d7",
    "32c761cd192dd9f83cf8e5470b5b13d5c480354a9cc03f1e96799cb1d5cc9ea3",
    "80dd99e14d2c66bc735899562d74666b2d2e1515d4b50fb3c1b40530d2d3d389",
    "91be8e03305ef3d54111642614f24106658bcf0ee766085fc74b5199f15584de",
    "faeab8d22a0b05d352d3762a55a86d056b8b0006bff5d94ace6fab9bb10049fe",
    "4128852a4190a9cc42a7a89a5bf191b776e2cf39f784d21d3fa9d4cd7e2328c8",
    "1f292743977c36202088586ba7db1b7295eeb2ab76d2c31d87bb3acc10a44a39",
    "b67565ab4320951a7969d3ab50fbef9215c162fb4b5260ea70e34ec023494334",
    "af968ebe3f27b7ffd5c44b5a4eeb62aa8bd530fa3b87412c8f635e116f9c05ce",
    "66ad0b735e84af5078be9d9efd41037c593fda7d58b73a7080fc6151fc3ba5b0",
    "ca175b3da4e8b602735ebe7a6c2b82fa5903604917eb84542679c90a0151dfa3",
    "f6cad01ca89e92ff57f7707c54d1c6550e0686122cbdb16bc2983002c55aa23f",
    "659945af8b0cf8c37838d7607aa1215a0e2fbc3f403489902141245966007a80",
    "0f3686558e565a67c9f51dfa878450e3abee41c1fe5ffa57a37eebbb657bce26",
    "ca32bfcd7a4c587ba65a15d9280cbd50acfbc876d3f062eed1099c6519e84a30",
    "3805a38547846ba9490b1eaa7da50db123a1ff201b272309f9442f22630aeeaf",
    "46950f2fc825403eb337b8737677f5afcd822cb137a547d203015a0e7455bda6",
    "0b93676852484647f0d49d57b8e7c8eabdb7a736585b501001114b4e2cf304f0",
    "73e543420410ed180adbf5a87e1c11b332a08e29a93241c17532c880e493b14c",
    "644cbb3eb45843c7bae6ab436cadbfedc3da860da7092301b05055569ce3ba6c",
    "3425cf295845366554c0e4108188a0441326923d69777ae9761c99ed6a78782f",
    "a15c1c2d708a4fde61fdc8cff4e1534eacc15229041415a19d89c975294558f4",
    "abcc5de2d7231ee7b5e0ef7ba1ffb3c2f8891e24002d14254d81db63fc804a10",
    "37e808816573f7c73b3f225d09b29e03fe9ae9f79c40e69eb466fc3cafc5cdc0",
    "450b46d575fdee83001a755b61fe4e4cd98fa880ebd4b6f3904716ac3a619a42",
    "e1800c7360563410f703163e2b8975cd8d272f58768ebed263ee8a8381054d81",
  ];

  // Example usage
  const result = borromeanSign(e0, s, pubs, k, sec, rsizes, secidx, nrings, m);
  console.log("e0 expected", e0Final);
  console.log("e0 actual", etc.bytesToHex(e0))
}

testBorromeanSign();
